<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms Repository on Algorithms</title>
    <link>http://walterjgsp.github.io/algorithms/pt/</link>
    <description>Recent content in Algorithms Repository on Algorithms</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 30 Sep 2019 06:59:48 -0300</lastBuildDate>
    
	<atom:link href="http://walterjgsp.github.io/algorithms/pt/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Letter Combinations of a Phone Number</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/134_letter_combinations_phone_number/</link>
      <pubDate>Mon, 30 Sep 2019 06:59:48 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/134_letter_combinations_phone_number/</guid>
      <description>Enunciado do problema  Dada uma sequência contendo dígitos de 2 a 9, inclusive, retorne todas as combinações possíveis de letras que o número possa representar.
O mapeamento do dígito para as letras é {2, &amp;ldquo;abc&amp;rdquo;}, {3, &amp;ldquo;def&amp;rdquo;}, {4, &amp;ldquo;ghi&amp;rdquo;}, {5, &amp;ldquo;jkl&amp;rdquo;}, {6, &amp;ldquo;mno&amp;rdquo;}, {7, &amp;ldquo;pqrs&amp;rdquo;}, {8, &amp;ldquo;tuv&amp;rdquo;}, {9, &amp;ldquo;wxyz&amp;rdquo;}. Observe que 1 não é mapeado para nenhuma letra.
Solução  Para resolver esse problema, usamos uma abordagem recursiva. Primeiro, definimos um caso base, que fará com que nossas chamadas recursivas parem.</description>
    </item>
    
    <item>
      <title>Lista encadeada</title>
      <link>http://walterjgsp.github.io/algorithms/pt/structures/list/</link>
      <pubDate>Thu, 11 Jul 2019 19:05:13 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/structures/list/</guid>
      <description>Definição  &amp;hellip; Sua estrutura aqui
Complexidades    Operação Caso médio Pior caso     Espaço O(n) O(n)   Busca O(n) O(n)     Implementação  </description>
    </item>
    
    <item>
      <title>Trie</title>
      <link>http://walterjgsp.github.io/algorithms/pt/structures/trie/</link>
      <pubDate>Thu, 11 Jul 2019 19:05:07 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/structures/trie/</guid>
      <description>Definição  &amp;hellip; Sua estrutura aqui
Complexidades    Operação Caso médio Pior caso     Espaço O(n) O(n)   Busca O(n) O(n)     Implementação  </description>
    </item>
    
    <item>
      <title>Pilha</title>
      <link>http://walterjgsp.github.io/algorithms/pt/structures/stack/</link>
      <pubDate>Thu, 11 Jul 2019 04:15:17 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/structures/stack/</guid>
      <description>Definição  A pilha é uma estrutura de dados para conter objetos obedecendo a ordem de entrada LIFO (Last In First Out). Isso significa que o primeiro elemento a ser adicionado sera o último elemento a sair. Em sua forma mais clássica ela implementa as seguintes operações:
 Top : essa operação retorna o último elemento adicionado a pilha, em alguns casos pode ser também implementada como Peek Push: a operação adiciona um elemento na última posição da pilha Pop : essa operação remove um elemento da última posição da pilha.</description>
    </item>
    
    <item>
      <title>Fila</title>
      <link>http://walterjgsp.github.io/algorithms/pt/structures/queue/</link>
      <pubDate>Thu, 04 Jul 2019 19:40:35 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/structures/queue/</guid>
      <description>Definição  A fila é uma estrutura de dados para conter objetos obedecendo a ordem de entrada FIFO( First In First Out ). Isso significa que o primeiro elemento a ser adicionado sera o primeiro elemento a sair. Em sua forma mais clássica ela implementa as seguintes operações:
 Peek : essa operação retorna o primeiro elemento da fila, em alguns casos pode ser também implementada como Front Push: a operação adiciona um elemento na última posição da fila Pop : essa operação remove um elemento da primeira posição da fila.</description>
    </item>
    
    <item>
      <title>Combination Sum II</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/110_combination_sum_ii/</link>
      <pubDate>Wed, 12 Jun 2019 21:59:28 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/110_combination_sum_ii/</guid>
      <description>Enunciado do problema  Dada uma coleção de números de candidatos (candidatos) e um número de destino (meta), localize todas as combinações exclusivas em candidatos em que os números dos candidatos somam a meta.
Cada número em candidatos só pode ser usado uma vez na combinação.
Nota:
Todos os números (incluindo o alvo) serão inteiros positivos. O conjunto de soluções não deve conter combinações duplicadas.
Questões importantes  O vetor de entrada já esta ordenado?</description>
    </item>
    
    <item>
      <title>Remove Duplicate Letters</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/109_remove_duplicate_letters/</link>
      <pubDate>Sun, 09 Jun 2019 22:19:37 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/109_remove_duplicate_letters/</guid>
      <description>Enunciado do problema  Dada uma string que contém apenas letras minúsculas, remova as letras duplicadas para que cada letra apareça uma vez e somente uma vez. Você deve certificar-se de que seu resultado é o menor em ordem lexicográfica entre todos os resultados possíveis e que a posição das letras é mantido.
Solução  Para resolver esse problema, primeiramente vamos contar a frequência de cada caractere no texto de entrada.</description>
    </item>
    
    <item>
      <title>Trapping Rain Water</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/86_trapping_rain_water/</link>
      <pubDate>Sun, 31 Mar 2019 17:30:00 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/86_trapping_rain_water/</guid>
      <description>Enunciado do problema  Dados n inteiros não negativos representando um mapa de elevação onde a largura de cada barra é 1, calcule quanta água será retida após a chuva.
Questões importantes  Os limites do vetor também podem reter água? Não
Solução  Para resolver este problema, calcule dois arrays auxiliares contendo os valores máximos à direita e à esquerda de uma i-ésima posição. A altura menos o valor mínimo centered os dois vetores vai mostrar quanta água pode ficar presa em todas as posições do vetor.</description>
    </item>
    
    <item>
      <title>Sliding Window Maximum</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/85_sliding_window_maximum/</link>
      <pubDate>Thu, 28 Mar 2019 19:06:02 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/85_sliding_window_maximum/</guid>
      <description>Enunciado do problema  Dado um array nums, há uma janela deslizante de tamanho k que está se movendo da esquerda da matriz para a direita. Você só pode ver os números k na janela. Cada vez que a janela deslizante se move para a direita por uma posição. Retorne a janela deslizante máxima.
Questões importantes  Posso ter números negativos no meu vetor de entrada? sim
Solução  A ideia de resolver este problema é sempre manter o maior número encontrado como primeiro em uma janela deslizante.</description>
    </item>
    
    <item>
      <title>LRU Cache</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/80_lru_cache/</link>
      <pubDate>Wed, 20 Mar 2019 21:46:11 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/80_lru_cache/</guid>
      <description>Enunciado do problema  Projetar e implementar uma estrutura de dados para o cache LRU (Least Recently Used). Deve suportar as seguintes operações: obter e colocar.
get (key) - Obtém o valor (sempre será positivo) da chave se a chave existir no cache, caso contrário, retornará -1. put (chave, valor) - Defina ou insira o valor se a chave ainda não estiver presente. Quando o cache atingiu sua capacidade, ele deve invalidar o item usado menos recentemente antes de inserir um novo item.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/79_container_with_most_water/</link>
      <pubDate>Wed, 20 Mar 2019 06:40:40 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/79_container_with_most_water/</guid>
      <description>Enunciado do problema  Dados n inteiros não negativos a1, a2, &amp;hellip;, an, onde cada um representa um ponto na coordenada (i, ai). n linhas verticais são desenhadas de tal forma que os dois pontos finais da linha i estão em (i, ai) e (i, 0). Encontre duas linhas, que, juntamente com o eixo x, formam um contêiner, de modo que o contêiner contenha a maior quantidade de água.
Nota: Você não pode inclinar o recipiente e n é pelo menos 2.</description>
    </item>
    
    <item>
      <title>Word Break</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/78_word_break/</link>
      <pubDate>Mon, 18 Mar 2019 21:21:57 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/78_word_break/</guid>
      <description>Enunciado do problema  Dada uma string não vazia e um dicionário wordDict contendo uma lista de palavras não vazias, determine se s pode ser segmentado em uma seqüência separada por espaço de uma ou mais palavras do dicionário.
Nota:
A mesma palavra no dicionário pode ser reutilizada várias vezes na segmentação.
Você pode assumir que o dicionário não contém palavras duplicadas.
Solução  Começando do final ao começo, nós quebramos a palavra em duas partes.</description>
    </item>
    
    <item>
      <title>Longest Absolute File Path</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/75_longest_absolute_file_path/</link>
      <pubDate>Thu, 14 Mar 2019 09:29:55 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/75_longest_absolute_file_path/</guid>
      <description>Problem Statement  Suppose we abstract our file system by a string in the following manner:
The string &amp;ldquo;dir\n\tsubdir1\n\tsubdir2\n\t\tfile.ext&amp;rdquo; represents:
dirsubdir1subdir2file.ext  The directory dir contains an empty sub-directory subdir1 and a sub-directory subdir2 containing a file file.ext.
The string &amp;ldquo;dir\n\tsubdir1\n\t\tfile1.ext\n\t\tsubsubdir1\n\tsubdir2\n\t\tsubsubdir2\n\t\t\tfile2.ext&amp;rdquo; represents:
dirsubdir1file1.extsubsubdir1subdir2subsubdir2file2.ext  The directory dir contains two sub-directories subdir1 and subdir2. subdir1 contains a file file1.ext and an empty second-level sub-directory subsubdir1.</description>
    </item>
    
    <item>
      <title>Min Cost Climbing Stairs</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/74_min_cost_clibing_stairs/</link>
      <pubDate>Wed, 13 Mar 2019 21:30:24 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/74_min_cost_clibing_stairs/</guid>
      <description>Enunciado do problema  Em uma escada, o i-ésimo degrau tem algum custo de valor não negativo [i] atribuído (0 indexado).
Depois de pagar o custo, você pode subir um ou dois degraus. Você precisa encontrar o mínimo custo para chegar ao topo do andar, e você pode começar a partir do degrau com o índice 0 ou com o índice 1.
Solução  Para resolver este problema, vamos usar a programação dinâmica.</description>
    </item>
    
    <item>
      <title>Sum of Even Numbers After Queries</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/54_sum_of_even_numbers_after_queries/</link>
      <pubDate>Wed, 13 Mar 2019 09:02:23 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/54_sum_of_even_numbers_after_queries/</guid>
      <description>Enunciado do problema  Temos um vetor A de inteiros e um vetor de consultas de queries.
Para a i-ésima consulta val = queries[i][0], index = queries[i][1], adicionamos val a A[index]. Então, a resposta para a i-ésima consulta é a soma dos valores pares de A.
(Aqui, o índice dado = queries[i][1] é um índice baseado em 0, e cada consulta modifica permanentemente o array A.)
Retorna a resposta para todas as perguntas.</description>
    </item>
    
    <item>
      <title>Anagrams</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/06_anagrams/</link>
      <pubDate>Wed, 13 Mar 2019 06:58:22 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/06_anagrams/</guid>
      <description>Enunciado do problema  Dadas duas strings, a e b, que podem ou não ter o mesmo comprimento, determine o número mínimo de exclusões de caracteres necessárias para tornar a e b anagramas.
Qualquer caractere pode ser excluído de qualquer uma das strings.
Questões para fazer  Caracteres na string são apenas minúsculos? Sim
Podem existir caracteres especiais na string? Não
Solução  A solução é bem direta. Sabendo que o caractere é um número de 0 a 255, crie um vetor para contar a frequência dos caracteres da primeira string.</description>
    </item>
    
    <item>
      <title>Valid Anagram</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/37_valid_anagram/</link>
      <pubDate>Wed, 13 Mar 2019 06:57:57 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/37_valid_anagram/</guid>
      <description>Problem Statement  Dadas duas strings s e t, escreva uma função para determinar se t é um anagrama de s.
Questions to ask  Caracteres na string são apenas minúsculos? Sim
Podem existir caracteres especiais na string? Não
Solution  A solução é bem direta. Sabendo que o caractere é um número de 0 a 255, crie um vetor para contar a frequência dos caracteres da primeira string. Agora você passará pelo segundo array e removerá o caractere do array que conta a freqüência.</description>
    </item>
    
    <item>
      <title>Advantage Shuffle</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/04_advantage_suffle/</link>
      <pubDate>Mon, 11 Mar 2019 21:14:47 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/04_advantage_suffle/</guid>
      <description>Enunciado do problema  Dados dois vetores A e B de tamanho igual, a vantagem de A em relação a B é o número de índices i para os quais A[i]&amp;gt;B[i].
Retorne qualquer permutação de A que maximize sua vantagem em relação a B.
Questões para fazer  O vetor de entrada está ordenado? Não ordenado
O array de entrada é mutável ou somente leitura? Mutável
Posso ter números negativos no meu vetor de entrada?</description>
    </item>
    
    <item>
      <title>Sort Array By Parity</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/27_sort_array_parity/</link>
      <pubDate>Sat, 09 Mar 2019 14:29:27 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/27_sort_array_parity/</guid>
      <description>Enunciado do problema  Dado um array A de inteiros não negativos, retorne um array que consiste em todos os elementos pares de A, seguidos por todos os elementos ímpares de A.
Você pode retornar qualquer array de resposta que satisfaça essa condição.
Questões importantes  O array de entrada é mutável ou somente leitura? Mutável
Posso ter números negativos no meu vetor de entrada? sim
Solução  Existem duas soluções para esse problema com complexidade de tempo O(n) com apenas uma passada no vetor.</description>
    </item>
    
    <item>
      <title>Squares of a Sorted Array</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/71_squares_of_sorted_array/</link>
      <pubDate>Sat, 09 Mar 2019 01:26:01 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/71_squares_of_sorted_array/</guid>
      <description>Enunciado do problema  Dada um vetor de inteiros A ordenada em ordem não decrescente, retorne um vetor dos quadrados de cada número, também em ordem não decrescente ordenado.
Questões importantes  Posso ter números negativos no meu vetor de entrada? Sim
O array de entrada é mutável ou somente leitura? Não
Solução  A solução ingênua é percorrer o array calculando o quadrado de cada valor e adicionando o resultado em um array para retornar.</description>
    </item>
    
    <item>
      <title>Edit Distance</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/65_edit_distance/</link>
      <pubDate>Sat, 02 Mar 2019 15:26:52 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/65_edit_distance/</guid>
      <description>Problem Statement  Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.
You have the following 3 operations permitted on a word:
 Insert a character Delete a character Replace a character    Solution 
If word1 = &amp;ldquo;horse&amp;rdquo; and word2 = &amp;ldquo;ros&amp;rdquo;, how can we solve the problem? In a first look the problem seens much more complex than it is.</description>
    </item>
    
    <item>
      <title>Add Two Numbers</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/03_add_two_numbers/</link>
      <pubDate>Mon, 18 Feb 2019 21:24:09 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/03_add_two_numbers/</guid>
      <description>Enunciado do problema  Você recebe duas listas encadeadas não vazias que representam dois inteiros não negativos. Os dígitos são armazenados na ordem inversa e cada um de seus nós contém um único dígito. Adicione os dois números e retorne-os como uma lista encadeada.
Você pode assumir que os dois números não contêm nenhum zero inicial, exceto o próprio número 0.
Solução  Assumindo um nó da lista sendo este:</description>
    </item>
    
    <item>
      <title>Add One Row to Tree</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/02_add_one_row_to_tree/</link>
      <pubDate>Mon, 18 Feb 2019 19:24:15 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/02_add_one_row_to_tree/</guid>
      <description>Enunciado do problema  Dada a raiz de uma árvore binária, em seguida, valor v e profundidade d, é necessário adicionar uma linha de nós com o valor v na profundidade dada d. O nó raiz está na profundidade 1.
A regra de adição é: dada uma profundidade inteira positiva d, para cada nó da árvore NÃO nulo N na profundidade d-1, crie dois nós de árvore com o valor v como raiz da subárvore esquerda de N e raiz da subárvore direita.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://walterjgsp.github.io/algorithms/pt/faq/how_to_c/</link>
      <pubDate>Sun, 17 Feb 2019 19:22:35 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/faq/how_to_c/</guid>
      <description>Todo código feito para C++ usa a versão C++14. Para compilar execute o seguinte comando:
g++ -std=c++14 &amp;lt;INPUT_FILE_NAME&amp;gt; -o &amp;lt;OUTPUT_FILE_NAME&amp;gt; E para rodar o código e verificar os resultados:
./&amp;lt;OUTPUT_FILE_NAME&amp;gt; </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>http://walterjgsp.github.io/algorithms/pt/problems/01_two_sum/</link>
      <pubDate>Sat, 16 Feb 2019 19:37:40 -0200</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/problems/01_two_sum/</guid>
      <description>Enunciado do problema  Dado um vetor de números inteiros, retorne os índices dos dois números de forma que eles se somem a um alvo específico.
Você pode assumir que cada entrada teria exatamente uma solução, e você não pode usar o mesmo elemento duas vezes.
Questões para fazer  O vetor já esta ordenado? Não
O array de entrada é mutável ou somente leitura? Mutável
Solução  Existem três abordagens principais para resolver este problema: Naive, Time Optimized, Memory Optimized.</description>
    </item>
    
    <item>
      <title></title>
      <link>http://walterjgsp.github.io/algorithms/pt/faq/how_to_kotlin/</link>
      <pubDate>Sun, 17 Feb 2019 19:30:50 -0300</pubDate>
      
      <guid>http://walterjgsp.github.io/algorithms/pt/faq/how_to_kotlin/</guid>
      <description>Para compilar código em Kotlin use o seguinte comando:
kotlinc &amp;lt;INPUT_FILE_NAME&amp;gt; -include-runtime -d &amp;lt;OUTPUT_FILE_NAME&amp;gt;.jar E para executar o código:
java -jar &amp;lt;OUTPUT_FILE_NAME&amp;gt; </description>
    </item>
    
  </channel>
</rss>